Testing strategy

1. Firstly, it is important to ensure that the functional functions within the program are correct. This is because these functions can be tested with very short assumption test functions. Also, errors that are not as expected can be ruled out as a result of incomplete functional functions if they are encountered while ensuring that the functional functions work correctly. 

By using the white-box testing strategy, some asserting functions were written in the nuclei.c, aiming to ensure the functional functions (e.g., “get words from string”, “find variable or lisp name from stack”) performed as expected. All functional functions will be tested before the program is run. One test function has the possibility to test several functional functions and to make assumptions after calling each function under test.

2. After ensured the functional functions performed well, in order to avoid the test function too long, a number of new ".ncl" files (e.g., double loops, extension features and some special cases) was added to applying the black-box testing and focus on whether the outputs meet the expectations. This is used to ensure that the sorting and navigation functions in the program are working correctly while also checking that the program output to a specific formats (i.e., ".ires" and ".pres") of file is correct.

3. It is also important to check the error cases of functions. Each function's error cases in the program will be saved as ".ncl" files in the Test folder and after running the executable files which generated by Makefile, the output observed is used to determine if they are as expected and to ensure that the error alerts for this function associated with them are correct.

One problem with this test is that there should be two left brackets after the Bool function in the Loop function. However, if there is only one left bracket after the Bool function, the program cannot tell where this bracket belongs, so it will just report it as an error inside the Instructs function. Also, the error message inside the Instructs function will be triggered by both the missing left and missing right bracket cases, so the error alert here is for both.

Another problem is that when reading a file with statements starting with single quotes and ending with double quotes or starting with double quotes and ending with single quotes, it neither conforms to the specification of literal nor string. So both of these are reported as errors at the Parser stage.

4. After all of the above stages had been tested as expected, I applied Valgrind to the program for memory testing to ensure that none of the functions had memory errors and that the "Prog_free" and other related free functions behaved well.

In this process, I found that if a lisp is reused in more than one structure at the same time, directly freeing the stack would result in a double free situation. Therefore, I split the lisp from the higher level structures in each case where it would be reused, to ensure that the free function frees the memory space correctly.
